= Paredit and Restricted Nodes
:toc:

== Status
Thinking & Exploring

== Paredit API
The `rewrite-clj.paredit` namespace was transcribed from rewrite-cljs when creating rewrite-clj v1.

Folks are starting to use the paredit API and therefore I am giving it some love and attention.

== Restricted Nodes
I invented this term for certain rewrite-clj nodes.

These nodes are special in that they can only specific significant children.
Insignificant children would be whitespace nodes.

For example a quote node:

* `'a` is parsed to a quote node with child of symbol node `a`
* `' a` is a quote node with child nodes of whitespace ` `, and symbol node `a`

I'm seeing the following as restricted nodes:

* `:quote` `'a`
* `:deref` `@a`
* `:eval` `#=a`
* `:syntax-quote` ``a`
* `:unquote` `~a`
* `:var` `#'a`

In the context of restricted nodes, I'll use the terms "root element" and "raw element".

|===
| Example | Root Element | Raw Element

a| `a'`
a| `a'`
a| `a'`

a| `'a'`
a| `'a'`
a| `a'`

a| `'''a'`
a| `'''a'`
a| `a'`

|===

== What am I missing?
I also must think about restricted nodes that have multiple children and how they are affected by paredit.

=== Metadata Nodes

* `:meta` `^a b`, `^{:a 1} b`
* `:raw-meta` `#^a b`, `#^{:a 1} b`

Metadata nodes are encoded as:

* :meta node with children:
** optional whitespace node(s)
** metadata node (map or symbol)
** optional whitespace node(s)
** data node (can be any node type)

TODO: Does rewrite-clj restrict children types?

Seems similar to other restricted nodes with the exception of the metadata node.

* I think if paredit treats the optional whitespace, metadata, optional whitespace nodes as a regular restricted node prefix, we should be good. Paredit does not operate on this portion.

* we can slurp into data, barf out of data
* what about split? does the created seq also get the metadata? probably not?: `^a [1 2 3]` => `^a [1] [2 3]`

=== Namespaced Map Nodes
There are also qualified maps to think about:

* `#:str{:a 1 :b 2}`
* `#::{:a 1 :b 2}`
* `#::alias{:a 1 :b 2}`

Namespace map nodes are encoded as:

* :namespace-map node with children
** :map-qualifier node
** :map node

I think we can take the same strategy as we do for metdata nodes.

=== Discard Nodes
And discard nodes (known to rewrite-clj as "uneval nodes"):

* ``#_,#_#_\n1 2 3``

The above uneval node is encoded as:

* :uneval node
** `,` comma node
** :uneval node
*** :uneval node
**** `\n` newline node
**** `1` token node
*** ` ` whitespace node
*** `2` token node
** ` ` whitespace node
** `3` token node

What could paredit ops effect on such a structure?

The only valid paredit op I see is wrap.
A raise within a significant node could work.

We could consider allowing paredit ops on the last significant node.
That might work nicely.
Paredit on other significant nodes that would affect node count would be a no-op.

But we could allow wrap on any significant node.
And raise within any significant node should be fine.


=== Reader Macro Nodes
* `:reader-macro` is a general catch all for any reader macro we don't handle specifically, examples:
** `#foo bar`
** `#?(:clj 1 :cljs 2)`
** `#?@(:clj [1] :cljs [2])`

Reader macro nodes are encoded as:

* :reader-macro node with children
** macro
** whitespace node(s)
** form-node

TODO: Thinky think.

== Paredit & Restricted Nodes

Paredit needs to understand the special single-significant-child case of restricted nodes.
For example, we can't slurp extra significant children into a quote node's chldren.

So we need to look at each paredit operation and see how restricted nodes impact it.

=== Slurp
Covers: `slurp-backward-fully-into`, `slurp-backward-fully`, `slurp-backward-into`, `slurp-backward`, `slurp-forward-fully-into`, `slurp-forward-fully`, `slurp-forward-into`, `slurp-forward`

Simple case: +
`[a |b c] d` => `[a |b c d]`

Simple retricted  case: +
`'''[a '|'b c] '''d` =>  `'''[a '|'b c '''d]`
We retain our position in the restricted node.
We slurp from the parent node of current element root.
We find the node to slurp to the right of that node's element root.
We slurp into slurp that node's element.

=== Barf
Covers: `barf-backward`, `barf-forward`

Simple case: `[a |b c d]` => `[a |b c] d`

Simple restricted case: +
`'''[a '|'b c '''d]` =>  `'''[a '|'b c] '''d`
Same concerns as slurp.

=== Kill
Covers: `kill`, `kill-at-pos`, `kill-one-at-pos`

If in or on a restricted element node, kill from the restricted element root node:

Simple restricted cases:

* `'''a |'''b`  => `|'''a'
* `'''a '|''b`  => `|'''a'
* `'''a '''|b`  => `|'''a'

=== Move
Coves: `move-to-prev`

If in or on a restricted element, move that element:

* `''a |''b ''c` => `|''b ''a ''c`
* `''a '|'b ''c` => `'|'b ''a ''c`
* `''a ''|b ''c` => `''|b ''a ''c`

=== Wrap
Covers: `wrap-around`, `wrap-fully-forward-slurp`

Wrapping is slightly nuanced for restricted nodes.

If at a restricted element's root or in a restricted node, it makes sense to wrap a the element root:

* `|'a'` => `[|'a]`
* `'|'a` => `['|'a]`

But if we are at the element, we wrap element:

* `''|a` => `''[|a]`

=== Join
Covers: `join`

Should we support restricted nodes for joins? If so, maybe:

* `''[a b c]| [d e f]` => `''[a b c |d e f]`
* `''[a b c]| ~'(d e f)` => `''[a b c |d e f]`

=== Split
Covers: `split`, `split-at-pos`

Should the split include the restricted prefix? I think no:

* `''(a b |c d e)` => `''(a b |c) (d e)`


=== Raise
Covers: `raise`

We'll raise the restricted node and preserve location in that node.

* `[1 [2 '|'3 4]]` => `[1 '|'3]`

I think we replace the parent root elem:

* `[1 ''[2 |''3 4]]` => `[1 |''3]`


=== Splice
Covers: `splice`, `splice-killing-forward`, `splice-killing-backward`

Splice also exists in rewrite-clj.zip api. I expect it doesn't deal with restricted nodes yet.

TODO: try

* `[|'[1 2 3] 4 5 6]`
* `['|[1 2 3] 4 5 6]`
* `''[|[1 2 3] 4 5 6]'`
* `''[''|[1 2 3] 4 5 6]'`
