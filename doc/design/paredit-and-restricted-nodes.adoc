= Paredit and Restricted Nodes
:toc:

== Status
Thinking & Exploring

== Conventions
In examples, `|` represents the location within the code.
For example, `[:a |:b :c]`, means the location in `[:a :b :c]` is at `:b`.

You'll see `ditto` in some examples, this means same as previous.

ğŸ¤” means up for more thinking/debate

== References
The original author of rewrite-clj/paredit based his implementation on the  https://pub.gajendra.net/src/paredit-refcard.pdf[Paredit Refcard] created by https://pub.gajendra.net/software[Dan Cross].

== Other Questions
I'll collect out of scope questions here.

=== node emptiness

We make certain decisions when a node is empty, but what is an emptyn node to paredit?
[source,clojure]
----
;; empty?
[
   ]

;; empty?
[
  ; foo

]
----
=== slurping and barfing comments
[source,clojure]
----
[1 |2 3] ;; slurp me too?
4

[1 |2 ;; when am I barfed?
3 ;; and when am I barfed??
]

;; when am I slurped?
1 ;; and when am I slurped?
[2 |3]
----

== Paredit API
The `rewrite-clj.paredit` namespace was transcribed from rewrite-cljs when creating rewrite-clj v1 in 2021.
As of this writing, in 2025, there is more interest in the paredit API.
People are actually trying to use it, and in doing so, have uncovered some issues.
I, therefore, I am giving the paredit API some love and attention.

Most fixes were relatively straightforward, but how paredit operations should act on "restricted nodes" is more nuanced, hence this design doc to think things through.

== Restricted Nodes
I invented this term for certain rewrite-clj nodes.
(Naming things is hard, I originally called these nodes "decorated nodes")

These nodes are special in that they can only have specific significant children.
Insignificant children would be whitespace nodes.

For example a quote node:

* `'a` is parsed to a quote node with child of symbol node `a`
* `' a` is a quote node with child nodes of whitespace `{nbsp}`, and symbol node `a`

I'm seeing the following as restricted nodes:

* `:quote` `'a`
* `:deref` `@a`
* `:eval` `#=a`
* `:syntax-quote` ``a`
* `:unquote` `~a`
* `:var` `#'a`

Unrestriced nodes that have any children are not a concern, for examples: `:set` `+#{1 2 3}+`, `:vector` `[:a :b :c]`, `:list` `(foo bar baz)`, and `:map` `{:a 1 :b 2}`.
And nodes that can't have children are exempt from concern, for examples: `:token` `a`, `:keyword` `:foo`, `:regex` `#"boo.*"`, `:comment` `;; foo`, `:whitespace` `{nbsp}`, `:newline` `\n`, and `:comma` `,`.

In the context of restricted nodes, I'll use the terms "root element" and "raw element".

|===
| Example | Root Element | Raw Element

a| `a`
a| `a`
a| `a`

a| `'a`
a| `'a`
a| `a`

a| `'''a`
a| `'''a`
a| `a`

|===

== What am I missing?
I also must think about restricted nodes that have multiple children and how they are affected by paredit.

=== Discard Nodes
Discard nodes (known to rewrite-clj as "uneval nodes"):

* `+#_,#_#_\n1 2 3+`

The above uneval node is encoded as:

* `:uneval` node
** `,` `:comma` node
** `:uneval` node
*** `:uneval` node
**** `\n` `:newline` node
**** `1` `:token` node
*** ` ` `:whitespace` node
*** `2` `:token` node
** ` ` `:whitespace` node
** `3` `:token` node

What could paredit ops effect on such a structure?

A wrap is fine:

* `+#_,#_#_\n|1 2 3+` => `+#_,#_#_\n[|1] 2 3+`

A raise __within__ a significant should be ok:

* `+#_,#_#_\n[|1] 2 3+` => `+#_,#_#_\n|1 2 3+`

Operations that change the number of nodes require some thought.
Any additional created nodes would be added outside of the `:uneval`.
Slurped nodes could be drawn in from outside the `:uneval`:

* `+#_#_#_1 2 [|3] 4+` => `+#_#_#_1 2 [|3 4]+` - `4` was slurped into last uneval

Technically, I guess if we have enough forms to satisfy the number of `#_`, we could allow the operation:

* `+#_#_#_1 [|2] 3 4+` => `+#_#_#_1 [|2 3] 4+` - `3` was slurp from last uneval to 2nd uneval, `4` is now in last uneval.

Forgetting rewrite-clj complexities, I think that's how, as a user, I'd expect things to work.

Once we get to a point where we don't have enough forms to satisfy the `#_`, the operation would be a no-op?

What about kill? Would I expect?:

* `+#_#_#_ 1 |2 3+` => `+#_#_ 1 3+`

Join is a similar scenario, do we remove an uneval?:

* `+#_#_#_ 1 [2]| [3]+` => `+#_#_ 1 [2 |3]+`

=== Metadata Nodes

* `:meta` `^a b`, `^{:a 1} b`
* `:raw-meta` `+#^a b+`, `+#^{:a 1} b+`

Metadata nodes are encoded as:

* `:meta` or `:raw-meta` node with children:
** optional whitespace node(s)
** metadata node (map or symbol)
** optional whitespace node(s)
** data node (can be any node type)

This seems similar to our simple one-child restricted nodes with the exception of the metadata node.

I think if paredit treats the optional whitespace, metadata, optional whitespace nodes as a regular restricted node prefix, we should be good.

But metatada can be complex.

[source,clojure]
----
(defn ^{:doc (some complex fn here)} foobar [])
----

So, ideally, we should allow paredit ops within the context of metadata. Hmmm...

We can slurp into data:

* `^{:a 1} [1 2 |3] 4` =>  `^{:a 1} [1 2 |3 4]`

Barf out of data

* `^{:a 1} [1 2 |3]` =>  `^{:a 1} [1 2] |3`


What about split?
Does the created seq also get the metadata?
No: `^a [|1 2 3]` => `^a [|1] [2 3]`

=== Namespaced Map Nodes
There are also qualified maps to think about:

* `#:str{:a 1 :b 2}`
* `#::{:a 1 :b 2}`
* `#::alias{:a 1 :b 2}`

Namespace map nodes are encoded as:

* :namespace-map node with children
** :map-qualifier node
** :map node

This is, I think, simpler than metadata nodes.
The prefix is a childless literal, so I think we can treat it like we do single child restricted nodes.

=== Reader Macro Nodes
* `:reader-macro` is a general catch all for any reader macro we don't handle specifically, examples:
** `#foo bar`
** `#?(:clj 1 :cljs 2)`
** `#?@(:clj [1] :cljs [2])`

Reader macro nodes are encoded as:

* :reader-macro node with children
** macro
** whitespace node(s)
** form-node

This more generic structure has 2 significant child nodes, the macro and the form.

I think we can take the same strategy as we do for metadata nodes.
Is it a bit simpler though?
I think the prefix (including the macro name) is always a literal.

== Paredit & Restricted Nodes

Paredit needs to understand the special single-significant-child case of restricted nodes.
For example, we can't slurp extra significant children into a quote node's chldren.

So we need to look at each paredit operation and see how restricted nodes impact it.

[[error-handling]]
=== Error handling
If paredit op is not supported, quiet no-op or throw?
I'm tending toward quiet no-op.

For example, if we try to slurp and there is no thing to slurp, an editor will quietly do nothing.

* `[1 |2 3]` => `[1 |2 3]`

This feels like doing nothing over an empty collection in clojure.

But rewrite-clj does throw for non-paredit ops.

*  a `rewrite-clj.zip/remove` on `#|foo [1 2 3]` will throw

But a `kill-one-at-pos` for the same node shouldn't?
ğŸ¤” Actually, what paredit will kill here is still TBD.

=== Slurp
Covers: `slurp-backward-fully-into`, `slurp-backward-fully`, `slurp-backward-into`, `slurp-backward`, `slurp-forward-fully-into`, `slurp-forward-fully`, `slurp-forward-into`, `slurp-forward`

Simple case: +
`[a |b c] d` => `[a |b c d]`

Simple retricted  case: +
`'''[a '|'b c] '''d` =>  `'''[a '|'b c '''d]`
We retain our position in the restricted node.
We slurp from the parent node of current element root.
We find the node to slurp to the right of that node's element root.
We slurp into slurp that node's element.

Let's explore how slurp forward behaves in editors:
[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 slurp forward
Â¦`'''[a '|'b c] '''d`

Â¦ emacs paredit
Â¦`'''[a '|'b c '''d]`

Â¦ calva
Â¦`ditto`

Â¦ rewrite-clj
Â¦ âœ… rewrite-clj will match editor behaviour
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 slurp forward
Â¦`+#_#_#_ 1 [|2] 3+`

Â¦ emacs paredit
Â¦ `+#_#_#_ 1 [|2 3]+`

Â¦ calva
Â¦`ditto`
Calva allows, but pops a warning about alignment.

Â¦ rewrite-clj
Â¦ âŒ This is not allowed in rewrite-clj, this results in an invalid `:uneval` node
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 slurp forward
Â¦ `^{:a 1 |:b 2} [1 2 3]`

Â¦ emacs paredit
Â¦ `^{:a 1 |:b 2 [1 2 3]}`

Â¦ calva
Â¦ `ditto`
Calva allows but pops an error: ":meta expects 2 values"

Â¦ rewrite-clj
Â¦ âŒ We can't get to this state in rewrite-clj, it is not a valid rewrite-clj `:meta` node.
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #4 slurp forward
Â¦ `#::str{:a 1 |:b 2} :c`

Â¦ emacs paredit
Â¦ `#::str{:a 1 |:b 2 :c}`

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ âœ… rewrite-clj allows unbalanced maps
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #5 slurp forward
Â¦ `+#_#_#_ 1 [|2] 3 4+`

Â¦ emacs paredit
Â¦ `+#_#_#_ 1 [|2 3] 4+`

Â¦ calva
Â¦ `ditto`
Calva does pop up a warning about formatting.

Â¦ rewrite-clj
Â¦ ğŸ¤”ï¸ï¸ Technically, rewrite-clj could support this scenario because there are enough nodes to satisfy `:uneval`
|===

Let's take a peek at how slurp backward behaves:
[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 slurp backward
Â¦`+'''d '''[a '|'b c]+`

Â¦emacs paredit
Â¦`'''['''d a '|'b c ]`

Â¦ calva
Â¦`ditto`

Â¦ rewrite-clj
Â¦ âœ… matches what we'd like to do for rewrite-clj
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 slurp backward
Â¦ `+#_#_#_ 1 [|2] 3+`

Â¦ emacs paredit
Â¦ `+#_#_#_ [1 |2] 3+`

Â¦ calva
Â¦`ditto`
Calva pops up a warning about formatting

Â¦ rewrite-clj
Â¦ âŒ This is not allowed in rewrite-clj, each `:uneval` must have a significant child node.
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 slurp backward
Â¦ `x ^{:a 1 |:b 2} [1 2 3]`

Â¦ emacs paredit
Â¦ `{x ^:a 1 |:b 2} [1 2 3]` hmmm... this seems like an odd and unhelpful behaviour.

Â¦ calva
Â¦ `^{x :a 1 |:b 2} [1 2 3]` this matches what rewrite-clj would do.
Calva allows, but pops up a error about :meta expecting 2 values, which is a bid odd (seems like will still have 2 nodes)

Â¦ rewrite-clj
Â¦ âœ…ï¸ rewrite-clj supports unbalanced maps and will match calva here
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #4 slurp backward
Â¦ `:x #::str{:a 1 |:b 2}`

Â¦ emacs paredit
Â¦ `:x {#::str :a 1 |:b 2}` hmmm... odd and unhelpful.

Â¦ calva
Â¦ `{:x #::str:a 1 |:b 2}` also not helpful.
Calva pops up an error about namespace map expecting a map

Â¦ rewrite-clj
Â¦ ğŸ¤”ï¸ rewrite-clj could suck in the `:x` like so `#::str{:x :a 1 |:b 2}`
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #5 slurp backward
Â¦ `+#_#_#_ [1 |2] 3 4+`

Â¦ emacs paredit
Â¦ `+[#_#_#_ 1 |2] 3 4+` oh my... that's not helpful

Â¦ calva
Â¦ `+#_#_ [#_ 1 |2] 3 4+` ugh... not good either

Â¦ rewrite-clj
Â¦ this would be a no-op for rewrite-clj, there is no valid slurpee candidate
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #6 slurp backward
Â¦ `+x #_#_#_ [|1] 2 3+`

Â¦ emacs paredit
Â¦ `+x [#_#_#_ |1] 2 3+` not helpful

Â¦ calva
Â¦ `+x #_#_[#_ |1] 2 3+` also not helpful

Â¦ rewrite-clj
Â¦ ğŸ¤” technically, rewrite-clj cold suck in the `x` like so `+#_#_#_ [x |1] 2 3+`
|===

Editors do allow some slurping that rewrite-clj cannot support because they result in invalid nodes.
In those cases we'll invoke our <<error-handling>>.

Rewrite-clj could, theoreticaly, handle some scenarios better than editors currently do.

=== Barf
Covers: `barf-backward`, `barf-forward`

Simple case: `[a |b c d]` => `[a |b c] d`

Simple restricted case: +
`'''[a '|'b c '''d]` =>  `'''[a '|'b c] '''d`

Let's explore how editors treat barf forward.

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 barf forward
Â¦ `'''[a '|'b c '''d]`

Â¦ emacs paredit
Â¦ `'''[a '|'b c] '''d`

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ âœ… rewrite-clj will match editor behaviour
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 barf forward
Â¦ `+#_#_#_ 1 [|2 3] 4+`

Â¦ emacs paredit
Â¦ `+#_#_#_ 1 [|2] 3 4+`

Â¦ calva
Â¦ `ditto`
Calva pops up a warning about alignment, but allows.

Â¦ rewrite-clj
Â¦ âœ… This matches what we want for rewrite-clj the `4` is effectively pushed out of the `:uneval`s
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 barf forward
Â¦`^{:a 1 |:b 2} [1 2 3]`

Â¦ emacs paredit
Â¦ `^{:a 1 |:b} 2 [1 2 3]`

Â¦ calva
Â¦ `ditto`
Calva pops up an error about `:meta` expecting values, but allows the operation.

Â¦ rewrite-clj
Â¦ ğŸ¤” I think rewrite-clj should behave as editors do here, the `[1 2 3]` data is pushed out of the `:meta` node and `2` becomes the data.

|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 barf forward
Â¦`+#::str{:a 1 |:b 2}+`

Â¦ emacs paredit
Â¦ `+#:str{:a 1 :b} 2+`

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ âœ… This matches what we want for rewrite-clj, it allows unbalanced maps.

|===

And let's look at some barf backward scenarios:

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 barf backward
Â¦ `'''['''d a '|'b c]`

Â¦ emacs paredit
Â¦ `'''d '''[a '|'b c]`

Â¦ calva
Â¦ `ditto`
Calva emits a warning about alignment, but allows the operation

Â¦ rewrite-clj
Â¦ âœ… This matches what we want for rewrite-clj.
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 barf backward
Â¦ `+#_#_#_ [1 |2] 3 4+`

Â¦ emacs paredit
Â¦ `+#_#_#_ 1 [|2] 3 4+`

Â¦ calva
Â¦ `ditto`
Calva emits a warning about alignment, but allows the operation

Â¦ rewrite-clj
Â¦ âœ… This matches what we want for rewrite-clj, the `4` is pushed out of the `:uneval`s
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 barf backward
Â¦`^{:a 1 |:b 2} [1 2 3]`

Â¦ emacs paredit
Â¦`:a ^{1 |:b 2} [1 2 3]`

Â¦ calva
Â¦ `ditto`
Calva emits an error about `:meta` node expecting 2 values, but allow operation

Â¦ rewrite-clj
Â¦ âœ… This matches what we'd like rewrite-clj to do
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #4 barf backward
Â¦`^{:a 1 :b 2} [1 |2 3]`

Â¦ emacs paredit
Â¦`^{:a 1 :b 2} 1 [|2 3]`

Â¦ calva
Â¦ `ditto`
Calva emits a warning about alignment, but allows operation

Â¦ rewrite-clj
Â¦ âœ… I think this matches what we'd like rewrite-clj to do, `1` becomes `:meta` data and `[2 3]` is pushed out of `:meta` node
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #5 barf backward
Â¦`#:str{:a 1 |:b 2}`

Â¦ emacs paredit
Â¦`#:str:a {1 :b 2}` ick, not helpful

Â¦ calva
Â¦`ditto` not helpful

Â¦ rewrite-clj
Â¦ ğŸ¤” I think we can do better and barf the `:a` out like so: `:a #:str{1 |:b 2}`
|===

=== Kill
Covers: `kill`, `kill-at-pos`, `kill-one-at-pos`

If in or on a restricted element node, kill from the restricted element root node:

Simple restricted cases:

* `'''a |'''b`  => `|'''a'`
* `'''a '|''b`  => `|'''a'`
* `'''a '''|b`  => `|'''a'`

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 kill
Â¦`+#_#_#_ 1 |2 3+`

Â¦ emacs paredit
Â¦`+#_#_#_ 1| +`

Â¦ calva
Â¦`ditto`

Â¦ rewrite-clj
Â¦ âŒ This is not allowed in rewrite-clj, each `:uneval` must have a significant child node. +
Â¦ ğŸ¤” Should rewrite-clj handle by removing associated leading `_#`? `#_ |1`, would this be more confusing than helpful?
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 kill
Â¦`+#_|#_#_ 1 2 3+`

Â¦ emacs paredit
Â¦`+#|_+`

Â¦ calva
Â¦`+#_|#_ 1 2 3+`
Calva does pop up an error about uneval expecting 1 node.

Â¦ rewrite-clj
Â¦ âŒ I don't think either editor is great and emacs results in an invalid `:uneval` node.
Â¦ ğŸ¤” Rewrite-clj could remove the entire node (we'd be left with nothing), this might be the simplest to understand for a user.
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 kill
Â¦`+#str|{:a 1 :b 2}+`

Â¦ emacs paredit
Â¦`#st|r`

Â¦ calva
Â¦`#str|`

Â¦ rewrite-clj
Â¦ âŒ This editor behaviour is not allowed in rewrite-clj a namespace map qualifier must have a map.
In this case rewrite-clj will kill the entire `:namespaced-map` node.
|===

=== Move
Coves: `move-to-prev`

If in or on a restricted element, move that element:

* `''a |''b ''c` => `|''b ''a ''c`
* `''a '|'b ''c` => `'|'b ''a ''c`
* `''a ''|b ''c` => `''|b ''a ''c`

I don't see a `move-to-prev` equivalent in emacs or calva.
Let's explore a few cases anyway.

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 move
Â¦`+:x #str|{:a 1 :b 2}+`

Â¦ rewrite-clj
Â¦`+#str|{:a 1 :b 2} :x+`
since we are at the prefix we'll move the entire node to prev
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 move
Â¦`+:x #str|{:a 1 :b 2}+`

Â¦ rewrite-clj
Â¦`+#str|{:a 1 :b 2} :x+`
since we are at the prefix we'll move the entire node to prev
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 move
Â¦`#str{|:a 1 :b 2}+`

Â¦ rewrite-clj
Â¦`+|:a #str{1 :b 2}+`
This case is much like barf backward
|===

TODO: Hmmm... `:uneval`...

=== Wrap
Covers: `wrap-around`, `wrap-fully-forward-slurp`

Wrapping is slightly nuanced for restricted nodes.

If at a restricted element's root or in a restricted node, it makes sense to wrap a the element root:

* `|'a` => `[|'a]`
* `'|'a` => `['|'a]`

But if we are at the element, we wrap element:

* `''|a` => `''[|a]`

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 wrap
Â¦`|'a`

Â¦ emacs paredit
Â¦`['a]`

Â¦ calva
Â¦`ditto`

Â¦ rewrite-clj
Â¦ âœ… matches our plan
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 wrap
Â¦`'|a`

Â¦ emacs paredit
Â¦`' [|a]`

Â¦ calva
Â¦ `['|a]`

Â¦ rewrite-clj
Â¦ ğŸ¤” Calva matches our plan, but emacs behaviour is worth considering (without extra space char)
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 wrap
Â¦`'|''a`

Â¦ emacs paredit
Â¦`' [|''a]`

Â¦ calva
Â¦ `['|''a]`

Â¦ rewrite-clj
Â¦ ğŸ¤” Again calva matches our plan, but emacs is worth considering (without extra space char).
|===

TODO: :meta, :uneval, :namespace-map


=== Join
Covers: `join`

Should we support restricted nodes for joins? If so, maybe:

* `''[a b c]| [d e f]` => `''[a b c |d e f]`
* `''[a b c]| ~'(d e f)` => `''[a b c |d e f]`

Let's seee what emacs and calva do:

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 join
Â¦`''[a b c]| [d e f]`

Â¦ emacs paredit
Â¦`''[a b c| d e f]`

Â¦ calva
Â¦`''[a b c |d e f]`

Â¦ rewrite-clj
Â¦ âœ… very similar behaviour, we match calva here
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 join
Â¦`''[a b c]| (d e f)`

Â¦ emacs paredit
Â¦`''[a b c]| (d e f)` no-op, does not join sequences of different types

Â¦ calva
Â¦`ditto`

Â¦ rewrite-clj
Â¦ ğŸ¤” Rewrite-clj does join sequences of different types, result here is `''[a b c |d e f]`
|===

Editors only join sequences of the same type, whereas rewrite-clj will join sequences of different types.
We'll preserve this historical behaviour.
If it doesn't suit users, they can either roll their own join, or we can add options to the `join` fn.

ğŸ¤” If the sequence on the left is a single child restricted node sequence, I think we'll also join it.

=== Split
Covers: `split`, `split-at-pos`

Should the split include the restricted prefix? I think no:

* `''(a b |c d e)` => `''(a b |c) (d e)`

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 split
Â¦`''(a b c d e)`

Â¦ emacs paredit
Â¦`''(a b)| (c d e)`

Â¦ calva
Â¦`''(a b)|''(c d e)`

Â¦ rewrite-clj
Â¦ ğŸ¤” Interesting.

* Calva includes the prefix, and emacs does not.
We'll go the emacs route and if that does not work for users, they can roll thier own `split` or we'll add some options to control behaviour.
* Another difference is that rewrite-clj keeps the position on the same node.
Given that it is less confusing to preserve ones location in zipper, I think this makes sense.
We'll stick with this historical behaviour.
|===

TODO:

* :meta
* :uneval
* :namespaced-map


=== Raise
Covers: `raise`

We'll raise the restricted node and preserve location in that node.

* `[1 [2 '|'3 4]]` => `[1 '|'3]`

I think we replace the parent root elem:

* `[1 ''[2 |''3 4]]` => `[1 |''3]`

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 raise
Â¦`[a [x '|'y z]]`

Â¦ emacs paredit
Â¦`[a |''y]`

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ âœ… rewrite-clj will also preserve position within restricted node, result will be `[a '|'y]`
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 raise
Â¦`[a ''[x '|'y z]]`

Â¦ emacs paredit
Â¦`[a ''|''y]` preserves parent sequence prefix

Â¦ calva
Â¦ `[a |''y]` does not preserve parent sequence prefix

Â¦ rewrite-clj
Â¦ ğŸ¤” We are leaning toward the calva behaviour, but we'll preserve location within the restricted node `[a |'|'y]`
|===

TODO:

* :uneval
* :namespace-map
* :meta

Unfortunately, the current `raise` works on the internal hierarchy of nodes (which I feel is an implementation detail):

* `''|3` => `'|3` => `|3`

ğŸ¤” Choices:

1. make a breaking change
2. add a new `raise` fn that matches new behaviour
3. add an option to existing raise fn that defaults to old behaviour but allows new behaviour

=== Splice
Covers: `splice`, `splice-killing-forward`, `splice-killing-backward`

[cols="1,1",separator=Â¦]
|===
sÂ¦ #1 splice
Â¦`[1 |2 3]`

Â¦ emacs paredit
Â¦`1 |2 3`

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ ğŸ¤” This is what we'd like rewrite-clj to do, but this is a currently a no-op for rewrite-clj `splice`.
Read on to next example.
|===

[cols="1,1",separator=Â¦]
|===
sÂ¦ #2 splice
Â¦`|[1 2 3]`

Â¦ emacs paredit
Â¦`|[1 2 3]` a no-op

Â¦ calva
Â¦ `ditto`

Â¦ rewrite-clj
Â¦ ğŸ¤” This is the only way that `splice` currently works in rewrite-clj you must be located at the sequence.
|===

Ok. Rewrite-clj's `splice` is a bit interesting in that it does not match the conventional editor paredit splice.
It expects the location to a be at a sequence, not in a sequence.
I assume this design decision was made because one cannot be located in an empty rewrite-clj sequence.

The other splice functions `splice-killing-*` work when located in a sequence.

Splice also exists in rewrite-clj.zip api.
The paredit version simply calls to rewrite-clj.zip/splice.
I expect it doesn't deal with restricted nodes yet?

[cols="1,1",separator=Â¦]
|===
sÂ¦ #3 splice
Â¦`''[a '|'b c]`

Â¦ emacs paredit
Â¦`''a '|'b c` like `raise`, preserves parent prefix

Â¦ calva
Â¦ `a ''b| c'` odd location after splice, does not preserve parent prefix

Â¦ rewrite-clj
Â¦ ğŸ¤” Assuming we now work within the sequence (see above), I was thinking rewrite-clj should match calva, but with location within restricted node preserved `a '|'b c`.
|===


Unfortunately, rewrite-clj `splice` currently works on the raw node structure.
Like the current `raise`, it doesn't care about our concept restricted nodes.

And it currently breaks down when trying to splice into a restricted node:

* `'|[1 2 3]` => throws because a quote node can only have 1 non-whitespace form

This is what does happen, what should happen?
I think, as a user, I would expect:

* `'|1 2 3` <- only `1` is quoted after splice

This is a bit of a mess. What to do?
I think adding a new fn makes sense.
We'll leave the existing splice as is, we could consider deprecating `rewrite-clj.paredit/splice` (but not `rewrite-clj.zip/splice`).

What to call our new `splice`? `splice-to`?

If we only operate from within a sequence, we'll not be able to splice an empty sequence (because you cannot be located inside an empty sequence in a zipper).
If we still want to allow splicing an empty sequence, we'll need to support splicing when located at a sequence. Maybe we could adopt same options as `slurp-forward-into` `:from :parent` or `:from :current`.
