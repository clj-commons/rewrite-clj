= Paredit and Restricted Nodes
:toc:

== Status
Thinking & Exploring

== Conventions
In examples, `|` represents the location within the code.
For example, `[:a |:b :c]`, means the location in `[:a :b :c]` is at `:b`.

== References
The original author of rewrite-clj/paredit based his implementation on the  https://pub.gajendra.net/src/paredit-refcard.pdf[Paredit Refcard] created by https://pub.gajendra.net/software[Dan Cross].

== Paredit API
The `rewrite-clj.paredit` namespace was transcribed from rewrite-cljs when creating rewrite-clj v1 in 2021.
As of this writing, in 2025, there is more interest in the paredit API.
People are actually trying to use it, and in doing so, have uncovered some issues.
I, therefore, I am giving the paredit API some love and attention.

Most fixes were relatively straightforward, but how paredit operations should act on "restricted nodes" is more nuanced, hence this design doc to think things through.

== Restricted Nodes
I invented this term for certain rewrite-clj nodes.
(Naming things is hard, I originally called these nodes "decorated nodes")

These nodes are special in that they can only have specific significant children.
Insignificant children would be whitespace nodes.

For example a quote node:

* `'a` is parsed to a quote node with child of symbol node `a`
* `' a` is a quote node with child nodes of whitespace `{nbsp}`, and symbol node `a`

I'm seeing the following as restricted nodes:

* `:quote` `'a`
* `:deref` `@a`
* `:eval` `#=a`
* `:syntax-quote` ``a`
* `:unquote` `~a`
* `:var` `#'a`

Unrestriced nodes that have any children are not a concern, for examples: `:set` `+#{1 2 3}+`, `:vector` `[:a :b :c]`, `:list` `(foo bar baz)`, and `:map` `{:a 1 :b 2}`.
And nodes that can't have children are exempt from concern, for examples: `:token` `a`, `:keyword` `:foo`, `:regex` `#"boo.*"`, `:comment` `;; foo`, `:whitespace` `{nbsp}`, `:newline` `\n`, and `:comma` `,`.

In the context of restricted nodes, I'll use the terms "root element" and "raw element".

|===
| Example | Root Element | Raw Element

a| `a`
a| `a`
a| `a`

a| `'a`
a| `'a`
a| `a`

a| `'''a`
a| `'''a`
a| `a`

|===

== What am I missing?
I also must think about restricted nodes that have multiple children and how they are affected by paredit.

=== Discard Nodes
Discard nodes (known to rewrite-clj as "uneval nodes"):

* `+#_,#_#_\n1 2 3+`

The above uneval node is encoded as:

* `:uneval` node
** `,` `:comma` node
** `:uneval` node
*** `:uneval` node
**** `\n` `:newline` node
**** `1` `:token` node
*** ` ` `:whitespace` node
*** `2` `:token` node
** ` ` `:whitespace` node
** `3` `:token` node

What could paredit ops effect on such a structure?

A wrap is fine:

* `+#_,#_#_\n|1 2 3+` => `+#_,#_#_\n[|1] 2 3+`

A raise __within__ a significant should be ok:

* `+#_,#_#_\n[|1] 2 3+` => `+#_,#_#_\n|1 2 3+`

Operations that change the number of nodes require some thought.
Any additional created nodes would be added outside of the `:uneval`.
Slurped nodes could be drawn in from outside the `:uneval`:

* `+#_#_#_1 2 [|3] 4+` => `+#_#_#_1 2 [|3 4]+` - `4` was slurped into last uneval

Technically, I guess if we have enough forms to satisfy the number of `#_`, we could allow the operation:

* `+#_#_#_1 [|2] 3 4+` => `+#_#_#_1 [|2 3] 4+` - `3` was slurp from last uneval to 2nd uneval, `4` is now in last uneval.

Forgetting rewrite-clj complexities, I think that's how, as a user, I'd expect things to work.

Once we get to a point where we don't have enough forms to satisfy the `#_`, the operation would be a no-op?

What about kill? Would I expect?:

* `+#_#_#_ 1 |2 3+` => `+#_#_ 1 3+`

Join is a similar scenario, do we remove an uneval?:

* `+#_#_#_ 1 [2]| [3]+` => `+#_#_ 1 [2 |3]+`

=== Metadata Nodes

* `:meta` `^a b`, `^{:a 1} b`
* `:raw-meta` `+#^a b+`, `+#^{:a 1} b+`

Metadata nodes are encoded as:

* `:meta` or `:raw-meta` node with children:
** optional whitespace node(s)
** metadata node (map or symbol)
** optional whitespace node(s)
** data node (can be any node type)

This seems similar to our simple one-child restricted nodes with the exception of the metadata node.

I think if paredit treats the optional whitespace, metadata, optional whitespace nodes as a regular restricted node prefix, we should be good.

But metatada can be complex.

[source,clojure]
----
(defn ^{:doc (some complex fn here)} foobar [])
----

So, ideally, we should allow paredit ops within the context of metadata. Hmmm...

We can slurp into data:

* `^{:a 1} [1 2 |3] 4` =>  `^{:a 1} [1 2 |3 4]`

Barf out of data

* `^{:a 1} [1 2 |3]` =>  `^{:a 1} [1 2] |3`


What about split?
Does the created seq also get the metadata?
No: `^a [|1 2 3]` => `^a [|1] [2 3]`

=== Namespaced Map Nodes
There are also qualified maps to think about:

* `#:str{:a 1 :b 2}`
* `#::{:a 1 :b 2}`
* `#::alias{:a 1 :b 2}`

Namespace map nodes are encoded as:

* :namespace-map node with children
** :map-qualifier node
** :map node

This is, I think, simpler than metadata nodes.
The prefix is a childless literal, so I think we can treat it like we do single child restricted nodes.

=== Reader Macro Nodes
* `:reader-macro` is a general catch all for any reader macro we don't handle specifically, examples:
** `#foo bar`
** `#?(:clj 1 :cljs 2)`
** `#?@(:clj [1] :cljs [2])`

Reader macro nodes are encoded as:

* :reader-macro node with children
** macro
** whitespace node(s)
** form-node

This more generic structure has 2 significant child nodes, the macro and the form.

I think we can take the same strategy as we do for metadata nodes.
Is it a bit simpler though?
I think the prefix (including the macro name) is always a literal.

== Paredit & Restricted Nodes

Paredit needs to understand the special single-significant-child case of restricted nodes.
For example, we can't slurp extra significant children into a quote node's chldren.

So we need to look at each paredit operation and see how restricted nodes impact it.

[[error-handling]]
=== Error handling
If paredit op is not supported, quiet no-op or throw?
I'm tending toward quiet no-op.

But rewrite-clj does throw for non-paredit ops.

*  a `rewrite-clj.zip/remove` on `#|foo [1 2 3]` will throw

But a `kill-one-at-pos` for the same node shouldn't?

=== Slurp
Covers: `slurp-backward-fully-into`, `slurp-backward-fully`, `slurp-backward-into`, `slurp-backward`, `slurp-forward-fully-into`, `slurp-forward-fully`, `slurp-forward-into`, `slurp-forward`

Simple case: +
`[a |b c] d` => `[a |b c d]`

Simple retricted  case: +
`'''[a '|'b c] '''d` =>  `'''[a '|'b c '''d]`
We retain our position in the restricted node.
We slurp from the parent node of current element root.
We find the node to slurp to the right of that node's element root.
We slurp into slurp that node's element.

Let's explore how slurp forward behaves in editors:
[cols="1,1"]
|===
s| #1 slurp forward
|`'''[a '\|'b c] '''d`

| emacs paredit
|`'''[a '\|'b c '''d]`

| calva
|`ditto`

| rewrite-clj
| ‚úÖ rewrite-clj will match editor behaviour
|===

[cols="1,1"]
|===
s| #2 slurp forward
|`+#_#_#_ 1 [\|2] 3+`

| emacs paredit
| `+#_#_#_ 1 [\|2 3]+`

| calva
|`ditto`
Calva allows, but pops a warning about alignment.

| rewrite-clj
| ‚ùå This is not allowed in rewrite-clj, this results in an invalid `:uneval` node
|===

[cols="1,1"]
|===
s| #3 slurp forward
| `^{:a 1 \|:b 2} [1 2 3]`

| emacs paredit
| `^{:a 1 \|:b 2 [1 2 3]}`

| calva
| `ditto`
Calva allows but pops an error: ":meta expects 2 values"

| rewrite-clj
| ‚ùå We can't get to this state in rewrite-clj, it is not a valid rewrite-clj `:meta` node.
|===

[cols="1,1"]
|===
s| #4 slurp forward
| `#::str{:a 1 \|:b 2} :c`

| emacs paredit
| `#::str{:a 1 \|:b 2 :c}`

| calva
| `ditto`

| rewrite-clj
| ‚úÖ rewrite-clj allows unbalanced maps
|===

[cols="1,1"]
|===
s| #5 slurp forward
| `+#_#_#_ 1 [\|2] 3 4+`

| emacs paredit
| `+#_#_#_ 1 [\|2 3] 4+`

| calva
| `ditto`
Calva does pop up a warning about formatting.

| rewrite-clj
| ü§îÔ∏èÔ∏è Technically, rewrite-clj could support this scenario because there are enough nodes to satisfy `:uneval`
|===


Let's take a peek at how slurp backward behaves:
[cols="1,1"]
|===
s| #1 slurp backward
|`+'''d '''[a '\|'b c]+`

|emacs paredit
|``'''['''d a '\|'b c ]`

| calva
|`ditto`

| rewrite-clj
| ‚úÖ matches what we'd like to do for rewrite-clj
|===

[cols="1,1"]
|===
s| #2 slurp backward
| `+#_#_#_ 1 [\|2] 3+`

| emacs paredit
| `+#_#_#_ [1 \|2] 3+`

| calva
|`ditto`
Calva pops up a warning about formatting

| rewrite-clj
| ‚ùå This is not allowed in rewrite-clj, each `:uneval` must have a significant child node.
|===

[cols="1,1"]
|===
s| #3 slurp backward
| `x ^{:a 1 \|:b 2} [1 2 3]`

| emacs paredit
| `{x ^:a 1 \|:b 2} [1 2 3]` hmmm... this seems like an odd and unhelpful behaviour.

| calva
| `^{x :a 1 \|:b 2} [1 2 3]` this matches what rewrite-clj would do.
Calva allows, but pops up a error about :meta expecting 2 values, which is a bid odd (seems like will still have 2 nodes)

| rewrite-clj
| ‚úÖÔ∏è rewrite-clj supports unbalanced maps and will match calva here
|===

[cols="1,1"]
|===
s| #4 slurp backward
| `:x #::str{:a 1 \|:b 2}`

| emacs paredit
| `:x {#::str :a 1 \|:b 2}` hmmm... odd and unhelpful.

| calva
| `{:x #::str:a 1 \|:b 2}` also not helpful.
Calva pops up an error about namespace map expecting a map

| rewrite-clj
| ü§îÔ∏è rewrite-clj could suck in the :x `#::str{:x :a 1 \|:b 2}`
|===

[cols="1,1"]
|===
s| #5 slurp backward
| `+#_#_#_ [1 \|2] 3 4+`

| emacs paredit
| `+[#_#_#_ 1 \|2] 3 4+` oh my... that's not helpful

| calva
| `+#_#_ [#_ 1 \|2] 3 4+` ugh... not good either

| rewrite-clj
| this would be a no-op for rewrite-clj, ther is no valid slurpee candidate
|===

[cols="1,1"]
|===
s| #6 slurp backward
| `+x #_#_#_ [\|1] 2 3+`

| emacs paredit
| `+x [#_#_#_ \|1] 2 3+` not helpful

| calva
| `+x #_#_[#_ \|1] 2 3+` also not helpful

| rewrite-clj
| ü§î Technically, rewrite-clj cold suck in the `x` like so `+#_#_#_ [x \|1] 2 3+`
|===

Editors do allow some slurping that rewrite-clj cannot support because they result in invalid nodes.
In those cases we'll invoke our <<error-handling>>.

Rewrite-clj could, theoreticaly, handle some scenarios better than editors currently do.

=== Barf
Covers: `barf-backward`, `barf-forward`

Simple case: `[a |b c d]` => `[a |b c] d`

Simple restricted case: +
`'''[a '|'b c '''d]` =>  `'''[a '|'b c] '''d`
Same concerns as slurp.




=== Kill
Covers: `kill`, `kill-at-pos`, `kill-one-at-pos`

If in or on a restricted element node, kill from the restricted element root node:

Simple restricted cases:

* `'''a |'''b`  => `|'''a'
* `'''a '|''b`  => `|'''a'
* `'''a '''|b`  => `|'''a'

=== Move
Coves: `move-to-prev`

If in or on a restricted element, move that element:

* `''a |''b ''c` => `|''b ''a ''c`
* `''a '|'b ''c` => `'|'b ''a ''c`
* `''a ''|b ''c` => `''|b ''a ''c`

=== Wrap
Covers: `wrap-around`, `wrap-fully-forward-slurp`

Wrapping is slightly nuanced for restricted nodes.

If at a restricted element's root or in a restricted node, it makes sense to wrap a the element root:

* `|'a'` => `[|'a]`
* `'|'a` => `['|'a]`

But if we are at the element, we wrap element:

* `''|a` => `''[|a]`

=== Join
Covers: `join`

Should we support restricted nodes for joins? If so, maybe:

* `''[a b c]| [d e f]` => `''[a b c |d e f]`
* `''[a b c]| ~'(d e f)` => `''[a b c |d e f]`

=== Split
Covers: `split`, `split-at-pos`

Should the split include the restricted prefix? I think no:

* `''(a b |c d e)` => `''(a b |c) (d e)`

=== Raise
Covers: `raise`

We'll raise the restricted node and preserve location in that node.

* `[1 [2 '|'3 4]]` => `[1 '|'3]`

I think we replace the parent root elem:

* `[1 ''[2 |''3 4]]` => `[1 |''3]`

TODO: This is not consistent with splice.
Probably best to become consistent with splice.
I think this means:

* `'|'3` => `|'3`

Is this intuitive?
These nodes are implemented in an hierarchy, but does a paredit user see them as such?

=== Splice
Covers: `splice`, `splice-killing-forward`, `splice-killing-backward`

Splice also exists in rewrite-clj.zip api.
The paredit version simply calls to rewrite-clj.zip/splice.
I expect it doesn't deal with restricted nodes yet?

Hmmm... Ok. This currently works on the raw node structure.
It doesn't care about my concept restricted nodes.

* `|''a` => `|'a`
* `|'a` => `a`

And it currently breaks down when trying to splice into a restricted node:

* `'|[1 2 3]` => throws because a quote node can only have 1 non-whitespace form

This is what does happen, what should happen?
I think, as a user, I would expect:

* `'|1 2 3` <- only `1` is quoted after splice
